/* eslint-disable */
// This file is auto-generated by scripts/generate-fallback-registry.js
// Do not edit this file directly. Update the source components instead.
import type { RegistryIndex, RegistryItem } from './types.js';

export const FALLBACK_REGISTRY_INDEX: RegistryIndex = [
  {
    "name": "bar-chart",
    "type": "chart",
    "category": "charts",
    "subcategory": "basic",
    "description": "A customizable bar chart component with animations, hover effects, responsive design, and support for both vertical and horizontal orientations with filled or outline variants",
    "dependencies": [
      "framer-motion"
    ],
    "devDependencies": [],
    "registryDependencies": [],
    "peerDependencies": [
      "react",
      "react-dom"
    ],
    "meta": {
      "importName": "BarChart",
      "exportName": "BarChart",
      "displayName": "Bar Chart"
    }
  },
  {
    "name": "line-chart",
    "type": "chart",
    "category": "charts",
    "subcategory": "basic",
    "description": "A sophisticated line chart component with triangular markers, textured area fills, multiple series support, gap handling, curve interpolation, and advanced animations",
    "dependencies": [
      "framer-motion"
    ],
    "devDependencies": [],
    "registryDependencies": [],
    "peerDependencies": [
      "react",
      "react-dom"
    ],
    "meta": {
      "importName": "LineChart",
      "exportName": "LineChart",
      "displayName": "Line Chart"
    }
  },
  {
    "name": "scatter-plot",
    "type": "chart",
    "category": "charts",
    "subcategory": "basic",
    "description": "A versatile scatter plot and bubble chart component with multi-series support, trend lines, dynamic bubble sizing, responsive design, and smooth animations",
    "dependencies": [
      "framer-motion"
    ],
    "devDependencies": [],
    "registryDependencies": [],
    "peerDependencies": [
      "react",
      "react-dom"
    ],
    "meta": {
      "importName": "ScatterPlot",
      "exportName": "ScatterPlot",
      "displayName": "Scatter Plot"
    }
  }
];

export const FALLBACK_COMPONENTS: Record<string, RegistryItem> = {
  "bar-chart": {
    "name": "bar-chart",
    "type": "chart",
    "category": "charts",
    "subcategory": "basic",
    "description": "A customizable bar chart component with animations, hover effects, responsive design, and support for both vertical and horizontal orientations with filled or outline variants",
    "dependencies": [
      "framer-motion"
    ],
    "devDependencies": [],
    "registryDependencies": [],
    "peerDependencies": [
      "react",
      "react-dom"
    ],
    "files": [
      {
        "name": "bar-chart/index.tsx",
        "content": "\"use client\";\r\n\r\nimport * as React from \"react\";\r\nimport { memo, useMemo, useState, useRef, useCallback } from \"react\";\r\nimport { useIsomorphicLayoutEffect } from \"../../../../lib/hooks\";\r\nimport { motion, AnimatePresence, useReducedMotion } from \"framer-motion\";\r\nimport { cn } from \"../../../../lib/utils\";\r\n\r\n// Types\r\ntype ChartDataItem = Record<string, unknown>;\r\n\r\ninterface BarChartProps<T extends ChartDataItem> {\r\n  readonly data: readonly T[];\r\n  readonly x: keyof T;\r\n  readonly y?: keyof T;\r\n  readonly colors?: readonly string[];\r\n  readonly className?: string;\r\n  readonly height?: number;\r\n  readonly loading?: boolean;\r\n  readonly error?: string | null;\r\n  readonly animation?: boolean;\r\n  readonly variant?: 'filled' | 'outline';\r\n  readonly orientation?: 'vertical' | 'horizontal';\r\n  readonly showGrid?: boolean;\r\n  readonly gridStyle?: 'solid' | 'dashed' | 'dotted';\r\n  readonly onBarClick?: (data: T, index: number) => void;\r\n}\r\n\r\n// Constants\r\nconst DEFAULT_COLORS = [\r\n  '#3b82f6', '#10b981', '#f59e0b', '#ef4444', '#8b5cf6', '#06b6d4',\r\n] as const;\r\n\r\nconst DEFAULT_HEIGHT = 300;\r\nconst MARGIN = { top: 20, right: 20, bottom: 40, left: 50 };\r\nconst ANIMATION_EASING = [0.4, 0, 0.2, 1] as const;\r\nconst HOVER_DURATION = 0.2;\r\n\r\n// Utilities\r\nfunction formatValue(value: unknown): string {\r\n  if (typeof value === 'number') {\r\n    if (Math.abs(value) >= 1000000) {\r\n      return `${(value / 1000000).toFixed(1)}M`;\r\n    } else if (Math.abs(value) >= 1000) {\r\n      return `${(value / 1000).toFixed(1)}K`;\r\n    }\r\n    return value.toLocaleString();\r\n  }\r\n  return String(value);\r\n}\r\n\r\nfunction getNumericValue(data: ChartDataItem, key: keyof ChartDataItem): number {\r\n  const value = data[key];\r\n  if (typeof value === 'number' && isFinite(value)) return value;\r\n  if (typeof value === 'string') {\r\n    const parsed = parseFloat(value.replace(/[,$%\\s]/g, ''));\r\n    if (isFinite(parsed)) return parsed;\r\n    if (process.env.NODE_ENV === 'development') {\r\n      console.warn(`[BarChart] Could not parse value \"${value}\" for key \"${String(key)}\". Using 0.`);\r\n    }\r\n  }\r\n  if (process.env.NODE_ENV === 'development' && value !== null && value !== undefined) {\r\n    console.warn(`[BarChart] Unexpected value type for key \"${String(key)}\": ${typeof value}. Using 0.`);\r\n  }\r\n  return 0;\r\n}\r\n\r\nfunction calculateNiceTicks(min: number, max: number, count = 5): number[] {\r\n  if (min === max) return [min];\r\n  const range = max - min;\r\n  const roughStep = range / (count - 1);\r\n  const magnitude = Math.pow(10, Math.floor(Math.log10(roughStep)));\r\n  const normalizedStep = roughStep / magnitude;\r\n  let niceStep: number;\r\n  if (normalizedStep <= 1) niceStep = magnitude;\r\n  else if (normalizedStep <= 2) niceStep = 2 * magnitude;\r\n  else if (normalizedStep <= 5) niceStep = 5 * magnitude;\r\n  else niceStep = 10 * magnitude;\r\n  const niceMin = Math.floor(min / niceStep) * niceStep;\r\n  const niceMax = Math.ceil(max / niceStep) * niceStep;\r\n  const ticks: number[] = [];\r\n  for (let tick = niceMin; tick <= niceMax; tick += niceStep) {\r\n    ticks.push(tick);\r\n  }\r\n  return ticks;\r\n}\r\n\r\nfunction getGridDasharray(gridStyle: 'solid' | 'dashed' | 'dotted'): string {\r\n  switch (gridStyle) {\r\n    case 'solid': return 'none';\r\n    case 'dotted': return '2 4';\r\n    case 'dashed':\r\n    default: return '4 4';\r\n  }\r\n}\r\n\r\nfunction useContainerDimensions() {\r\n  const ref = useRef<HTMLDivElement>(null);\r\n  const [width, setWidth] = useState(0);\r\n\r\n  useIsomorphicLayoutEffect(() => {\r\n    const element = ref.current;\r\n    if (!element) return;\r\n\r\n    const updateWidth = () => {\r\n      setWidth(element.getBoundingClientRect().width);\r\n    };\r\n\r\n    updateWidth();\r\n    const resizeObserver = new ResizeObserver(updateWidth);\r\n    resizeObserver.observe(element);\r\n\r\n    return () => resizeObserver.disconnect();\r\n  }, []);\r\n\r\n  return [ref, width] as const;\r\n}\r\n\r\n// Loading/Error States\r\nfunction LoadingState({\r\n  orientation = 'vertical',\r\n  variant = 'filled',\r\n  height = DEFAULT_HEIGHT\r\n}: {\r\n  orientation?: 'vertical' | 'horizontal';\r\n  variant?: 'filled' | 'outline';\r\n  height?: number;\r\n}) {\r\n  const isVertical = orientation === 'vertical';\r\n  const isFilled = variant === 'filled';\r\n\r\n  return (\r\n    <div className=\"relative w-full\" style={{ height }}>\r\n      <div className=\"flex items-center justify-center h-full p-6\">\r\n        <div className=\"w-full max-w-full\">\r\n          <div className=\"animate-pulse bg-muted rounded h-4 w-32 mb-4\" />\r\n          <div\r\n            className=\"relative border-l border-b border-muted/30\"\r\n            style={{\r\n              height: height - MARGIN.top - MARGIN.bottom - 50,\r\n              marginLeft: MARGIN.left,\r\n              marginRight: MARGIN.right,\r\n              marginBottom: MARGIN.bottom,\r\n            }}\r\n          >\r\n            <div className={`flex ${isVertical ? 'items-end space-x-2 h-full' : 'flex-col justify-center space-y-2 w-full'}`}>\r\n              {Array.from({ length: 5 }).map((_, i) => {\r\n                const barSize = isVertical\r\n                  ? { width: 32, height: 40 + (i * 20) }\r\n                  : { width: 60 + (i * 30), height: 24 };\r\n\r\n                return (\r\n                  <div\r\n                    key={i}\r\n                    className={`${isFilled ? 'bg-muted' : 'border-2 border-muted bg-transparent'} rounded animate-pulse`}\r\n                    style={{\r\n                      width: barSize.width,\r\n                      height: barSize.height,\r\n                      animationDelay: `${i * 0.1}s`\r\n                    }}\r\n                  />\r\n                );\r\n              })}\r\n            </div>\r\n            <div className={`absolute ${isVertical ? 'bottom-0 left-0 right-0 flex justify-around mt-2' : 'left-0 top-0 bottom-0 flex flex-col justify-around -ml-8'}`}>\r\n              {Array.from({ length: 5 }).map((_, i) => (\r\n                <div\r\n                  key={`label-${i}`}\r\n                  className=\"animate-pulse bg-muted rounded h-3 w-8\"\r\n                  style={{ animationDelay: `${(i + 5) * 0.1}s` }}\r\n                />\r\n              ))}\r\n            </div>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\nfunction ErrorState({ error }: { error: string }) {\r\n  return (\r\n    <div className=\"flex items-center justify-center h-64\">\r\n      <div className=\"text-center space-y-2\">\r\n        <div className=\"text-destructive font-medium\">Chart Error</div>\r\n        <div className=\"text-sm text-muted-foreground\">{error}</div>\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\nfunction EmptyState() {\r\n  return (\r\n    <div className=\"flex items-center justify-center h-64\">\r\n      <div className=\"text-center space-y-2\">\r\n        <div className=\"text-muted-foreground\">No Data</div>\r\n        <div className=\"text-sm text-muted-foreground\">\r\n          There&apos;s no data to display\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\n// Main Component\r\nfunction BarChartComponent<T extends ChartDataItem>({\r\n  data,\r\n  x,\r\n  y = 'value' as keyof T,\r\n  colors = DEFAULT_COLORS,\r\n  className,\r\n  height = DEFAULT_HEIGHT,\r\n  loading = false,\r\n  error = null,\r\n  animation = true,\r\n  variant = 'filled',\r\n  orientation = 'vertical',\r\n  showGrid = false,\r\n  gridStyle = 'dashed',\r\n  onBarClick,\r\n}: BarChartProps<T>) {\r\n  const [containerRef, containerWidth] = useContainerDimensions();\r\n  const [hoveredIndex, setHoveredIndex] = useState<number | null>(null);\r\n\r\n  const reduceMotion = useReducedMotion();\r\n  const shouldAnimate = animation && !reduceMotion;\r\n\r\n  const chartWidth = Math.max(0, containerWidth - MARGIN.left - MARGIN.right);\r\n  const chartHeight = height - MARGIN.top - MARGIN.bottom;\r\n\r\n  // Dev warning for large datasets\r\n  if (process.env.NODE_ENV === 'development' && data.length > 50) {\r\n    console.warn(\r\n      `[BarChart] ${data.length} data points detected. Consider pagination or a different visualization for large datasets.`\r\n    );\r\n  }\r\n\r\n  // Extract value domain for grid/ticks\r\n  const valueDomain = useMemo(() => {\r\n    if (!data.length) return { min: 0, max: 0 };\r\n    const values = data.map(d => getNumericValue(d, y as string));\r\n    const maxValue = Math.max(...values, 0);\r\n    return { min: 0, max: maxValue };\r\n  }, [data, y]);\r\n\r\n  const yTicks = useMemo(() => {\r\n    if (valueDomain.max <= 0) return [];\r\n    return calculateNiceTicks(0, valueDomain.max, 5);\r\n  }, [valueDomain]);\r\n\r\n  const gridDasharray = useMemo(() => getGridDasharray(gridStyle), [gridStyle]);\r\n\r\n  const processedBars = useMemo(() => {\r\n    if (!data.length || chartWidth <= 0 || chartHeight <= 0) return [];\r\n\r\n    const values = data.map(d => getNumericValue(d, y as string));\r\n    const maxValue = valueDomain.max;\r\n\r\n    const isVertical = orientation === 'vertical';\r\n    const barCount = data.length;\r\n\r\n    const barSize = isVertical ? chartWidth / barCount : chartHeight / barCount;\r\n    const barSpacing = barSize * 0.2;\r\n    const actualBarSize = barSize * 0.8;\r\n\r\n    if (maxValue <= 0) {\r\n      return data.map((item, index) => ({\r\n        data: item,\r\n        index,\r\n        x: isVertical ? index * barSize + barSpacing / 2 : 0,\r\n        y: isVertical ? chartHeight : index * barSize + barSpacing / 2,\r\n        width: isVertical ? actualBarSize : 0,\r\n        height: isVertical ? 0 : actualBarSize,\r\n        color: colors[index % colors.length] || DEFAULT_COLORS[0],\r\n        label: String(item[x]),\r\n        value: formatValue(values[index]),\r\n        rawValue: values[index]\r\n      }));\r\n    }\r\n\r\n    // Use niceMax from ticks for consistent scaling with grid\r\n    const scaleMax = yTicks.length > 0 ? Math.max(...yTicks) : maxValue;\r\n\r\n    return data.map((item, index) => {\r\n      const value = values[index] || 0;\r\n\r\n      if (isVertical) {\r\n        const normalizedHeight = Math.max(0, (value / scaleMax) * chartHeight);\r\n        return {\r\n          data: item,\r\n          index,\r\n          x: index * barSize + barSpacing / 2,\r\n          y: chartHeight - normalizedHeight,\r\n          width: actualBarSize,\r\n          height: normalizedHeight,\r\n          color: colors[index % colors.length] || DEFAULT_COLORS[0],\r\n          label: String(item[x]),\r\n          value: formatValue(value),\r\n          rawValue: value\r\n        };\r\n      } else {\r\n        const normalizedWidth = Math.max(0, (value / scaleMax) * chartWidth);\r\n        return {\r\n          data: item,\r\n          index,\r\n          x: 0,\r\n          y: index * barSize + barSpacing / 2,\r\n          width: normalizedWidth,\r\n          height: actualBarSize,\r\n          color: colors[index % colors.length] || DEFAULT_COLORS[0],\r\n          label: String(item[x]),\r\n          value: formatValue(value),\r\n          rawValue: value\r\n        };\r\n      }\r\n    });\r\n  }, [data, x, y, colors, chartWidth, chartHeight, orientation, valueDomain, yTicks]);\r\n\r\n  // Event handlers with useCallback\r\n  const handleBarMouseEnter = useCallback((index: number) => {\r\n    setHoveredIndex(index);\r\n  }, []);\r\n\r\n  const handleBarMouseLeave = useCallback(() => {\r\n    setHoveredIndex(null);\r\n  }, []);\r\n\r\n  const handleBarClick = useCallback((barData: T, index: number) => {\r\n    onBarClick?.(barData, index);\r\n  }, [onBarClick]);\r\n\r\n  const handleKeyDown = useCallback((e: React.KeyboardEvent, barData: T, index: number) => {\r\n    if (e.key === 'Enter' || e.key === ' ') {\r\n      e.preventDefault();\r\n      onBarClick?.(barData, index);\r\n    }\r\n  }, [onBarClick]);\r\n\r\n  if (loading) return <LoadingState orientation={orientation} variant={variant} height={height} />;\r\n  if (error) return <ErrorState error={error} />;\r\n  if (!data.length) return <EmptyState />;\r\n\r\n  if (!containerWidth) {\r\n    return (\r\n      <div ref={containerRef} className={cn('relative w-full', className)} style={{ height }}>\r\n        <div className=\"flex items-center justify-center h-full text-sm text-muted-foreground\">\r\n          Loading...\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  const isVertical = orientation === 'vertical';\r\n  const scaleMax = yTicks.length > 0 ? Math.max(...yTicks) : valueDomain.max;\r\n\r\n  return (\r\n    <div\r\n      ref={containerRef}\r\n      className={cn('relative w-full', className)}\r\n      style={{ height }}\r\n    >\r\n      <svg\r\n        width=\"100%\"\r\n        height={height}\r\n        className=\"overflow-visible\"\r\n        role=\"img\"\r\n        aria-label={`Bar chart with ${data.length} bars in ${orientation} orientation`}\r\n      >\r\n        <g transform={`translate(${MARGIN.left}, ${MARGIN.top})`}>\r\n          {/* Grid lines */}\r\n          {showGrid && isVertical && scaleMax > 0 && yTicks.map((tick, i) => {\r\n            const tickY = chartHeight - (tick / scaleMax) * chartHeight;\r\n            return (\r\n              <line\r\n                key={`grid-h-${i}`}\r\n                x1={0}\r\n                y1={tickY}\r\n                x2={chartWidth}\r\n                y2={tickY}\r\n                stroke=\"currentColor\"\r\n                opacity={0.1}\r\n                strokeDasharray={gridDasharray}\r\n              />\r\n            );\r\n          })}\r\n          {showGrid && !isVertical && scaleMax > 0 && yTicks.map((tick, i) => {\r\n            const tickX = (tick / scaleMax) * chartWidth;\r\n            return (\r\n              <line\r\n                key={`grid-v-${i}`}\r\n                x1={tickX}\r\n                y1={0}\r\n                x2={tickX}\r\n                y2={chartHeight}\r\n                stroke=\"currentColor\"\r\n                opacity={0.1}\r\n                strokeDasharray={gridDasharray}\r\n              />\r\n            );\r\n          })}\r\n\r\n          {/* Axes */}\r\n          {isVertical ? (\r\n            <>\r\n              <line\r\n                x1={0} y1={0} x2={0} y2={chartHeight}\r\n                stroke=\"currentColor\" opacity={0.3} strokeWidth={1.5}\r\n              />\r\n              <line\r\n                x1={0} y1={chartHeight} x2={chartWidth} y2={chartHeight}\r\n                stroke=\"currentColor\" opacity={0.3} strokeWidth={1.5}\r\n              />\r\n            </>\r\n          ) : (\r\n            <>\r\n              <line\r\n                x1={0} y1={0} x2={0} y2={chartHeight}\r\n                stroke=\"currentColor\" opacity={0.3} strokeWidth={1.5}\r\n              />\r\n              <line\r\n                x1={0} y1={chartHeight} x2={chartWidth} y2={chartHeight}\r\n                stroke=\"currentColor\" opacity={0.1}\r\n              />\r\n            </>\r\n          )}\r\n\r\n          {/* Y-axis ticks and labels (vertical) / X-axis ticks and labels (horizontal) */}\r\n          {isVertical && scaleMax > 0 && yTicks.map((tick, i) => {\r\n            const tickY = chartHeight - (tick / scaleMax) * chartHeight;\r\n            return (\r\n              <g key={`y-tick-${i}`}>\r\n                <line x1={-4} y1={tickY} x2={0} y2={tickY} stroke=\"currentColor\" opacity={0.3} />\r\n                <text\r\n                  x={-8}\r\n                  y={tickY}\r\n                  textAnchor=\"end\"\r\n                  dominantBaseline=\"middle\"\r\n                  fontSize={11}\r\n                  className=\"fill-muted-foreground\"\r\n                >\r\n                  {formatValue(tick)}\r\n                </text>\r\n              </g>\r\n            );\r\n          })}\r\n          {!isVertical && scaleMax > 0 && yTicks.map((tick, i) => {\r\n            const tickX = (tick / scaleMax) * chartWidth;\r\n            return (\r\n              <g key={`x-tick-${i}`}>\r\n                <line x1={tickX} y1={chartHeight} x2={tickX} y2={chartHeight + 4} stroke=\"currentColor\" opacity={0.3} />\r\n                <text\r\n                  x={tickX}\r\n                  y={chartHeight + 16}\r\n                  textAnchor=\"middle\"\r\n                  fontSize={11}\r\n                  className=\"fill-muted-foreground\"\r\n                >\r\n                  {formatValue(tick)}\r\n                </text>\r\n              </g>\r\n            );\r\n          })}\r\n\r\n          {/* Bars */}\r\n          {processedBars.map((bar) => {\r\n            const isFilled = variant === 'filled';\r\n            const isHovered = hoveredIndex === bar.index;\r\n\r\n            const motionProps = shouldAnimate ? {\r\n              initial: isVertical ? { scaleY: 0 } : { scaleX: 0 },\r\n              animate: isVertical ? { scaleY: 1 } : { scaleX: 1 },\r\n              transition: {\r\n                duration: 0.6,\r\n                delay: bar.index * 0.05,\r\n                ease: ANIMATION_EASING,\r\n              },\r\n            } : {};\r\n\r\n            const transformOrigin = isVertical\r\n              ? `${bar.x + bar.width/2}px ${bar.y + bar.height}px`\r\n              : `${bar.x}px ${bar.y + bar.height/2}px`;\r\n\r\n            return (\r\n              <g key={bar.index}>\r\n                {/* Invisible hit area for outline variant */}\r\n                {!isFilled && (\r\n                  <rect\r\n                    x={bar.x}\r\n                    y={bar.y}\r\n                    width={bar.width}\r\n                    height={bar.height}\r\n                    fill=\"transparent\"\r\n                    className=\"cursor-pointer touch-manipulation focus:outline-none focus-visible:ring-2 focus-visible:ring-ring\"\r\n                    tabIndex={0}\r\n                    role=\"graphics-symbol\"\r\n                    aria-label={`${bar.label}: ${bar.value}`}\r\n                    onMouseEnter={() => handleBarMouseEnter(bar.index)}\r\n                    onMouseLeave={handleBarMouseLeave}\r\n                    onFocus={() => handleBarMouseEnter(bar.index)}\r\n                    onBlur={handleBarMouseLeave}\r\n                    onClick={() => handleBarClick(bar.data, bar.index)}\r\n                    onKeyDown={(e) => handleKeyDown(e, bar.data, bar.index)}\r\n                  />\r\n                )}\r\n\r\n                {/* Visible bar */}\r\n                <motion.rect\r\n                  x={bar.x}\r\n                  y={bar.y}\r\n                  width={bar.width}\r\n                  height={bar.height}\r\n                  fill={isFilled ? bar.color : 'none'}\r\n                  stroke={isFilled ? 'none' : bar.color}\r\n                  strokeWidth={isFilled ? 0 : 2}\r\n                  rx={4}\r\n                  className={cn(\r\n                    isFilled\r\n                      ? \"cursor-pointer touch-manipulation focus:outline-none focus-visible:ring-2 focus-visible:ring-ring\"\r\n                      : \"pointer-events-none\"\r\n                  )}\r\n                  style={{\r\n                    transformOrigin,\r\n                    filter: isHovered && !reduceMotion ? `drop-shadow(0 0 6px ${bar.color})` : 'none',\r\n                    transition: reduceMotion ? 'none' : `filter ${HOVER_DURATION}s ease-out`,\r\n                  }}\r\n                  {...motionProps}\r\n                  {...(isFilled && {\r\n                    tabIndex: 0,\r\n                    role: \"graphics-symbol\" as const,\r\n                    \"aria-label\": `${bar.label}: ${bar.value}`,\r\n                    onMouseEnter: () => handleBarMouseEnter(bar.index),\r\n                    onMouseLeave: handleBarMouseLeave,\r\n                    onFocus: () => handleBarMouseEnter(bar.index),\r\n                    onBlur: handleBarMouseLeave,\r\n                    onClick: () => handleBarClick(bar.data, bar.index),\r\n                    onKeyDown: (e: React.KeyboardEvent) => handleKeyDown(e, bar.data, bar.index),\r\n                  })}\r\n                />\r\n              </g>\r\n            );\r\n          })}\r\n\r\n          {/* X-axis labels (vertical) / Y-axis labels (horizontal) */}\r\n          {processedBars.map((bar) => (\r\n            <g key={`label-group-${bar.index}`}>\r\n              {/* Tick mark */}\r\n              {isVertical ? (\r\n                <line\r\n                  x1={bar.x + bar.width / 2}\r\n                  y1={chartHeight}\r\n                  x2={bar.x + bar.width / 2}\r\n                  y2={chartHeight + 4}\r\n                  stroke=\"currentColor\"\r\n                  opacity={0.3}\r\n                />\r\n              ) : (\r\n                <line\r\n                  x1={-4}\r\n                  y1={bar.y + bar.height / 2}\r\n                  x2={0}\r\n                  y2={bar.y + bar.height / 2}\r\n                  stroke=\"currentColor\"\r\n                  opacity={0.3}\r\n                />\r\n              )}\r\n              <text\r\n                x={isVertical ? bar.x + bar.width / 2 : -8}\r\n                y={isVertical ? chartHeight + 16 : bar.y + bar.height / 2}\r\n                textAnchor={isVertical ? \"middle\" : \"end\"}\r\n                dominantBaseline={isVertical ? \"auto\" : \"middle\"}\r\n                fontSize={11}\r\n                className=\"fill-muted-foreground\"\r\n              >\r\n                {bar.label}\r\n              </text>\r\n            </g>\r\n          ))}\r\n        </g>\r\n      </svg>\r\n\r\n      {/* Tooltip */}\r\n      <AnimatePresence>\r\n        {hoveredIndex !== null && processedBars[hoveredIndex] && (() => {\r\n          const bar = processedBars[hoveredIndex];\r\n\r\n          const tooltipStyle = isVertical ? {\r\n            left: bar.x + bar.width / 2 + MARGIN.left,\r\n            top: Math.max(10, bar.y + MARGIN.top - 60),\r\n          } : {\r\n            left: bar.x + bar.width + MARGIN.left + 10,\r\n            top: bar.y + bar.height / 2 + MARGIN.top,\r\n          };\r\n\r\n          return (\r\n            <motion.div\r\n              key=\"bar-tooltip\"\r\n              initial={{ opacity: 0, scale: 0.9 }}\r\n              animate={{ opacity: 1, scale: 1 }}\r\n              exit={{ opacity: 0, scale: 0.9 }}\r\n              transition={{ duration: 0.15, ease: 'easeOut' }}\r\n              className={cn(\r\n                \"absolute pointer-events-none z-50 bg-popover/98 backdrop-blur-md border border-border rounded-lg px-3 py-2.5 shadow-xl\",\r\n                isVertical ? 'transform -translate-x-1/2' : 'transform -translate-y-1/2'\r\n              )}\r\n              style={tooltipStyle}\r\n            >\r\n              <div className=\"flex items-center gap-2 mb-1\">\r\n                <div\r\n                  className=\"w-2.5 h-2.5 rounded-full\"\r\n                  style={{ backgroundColor: bar.color }}\r\n                />\r\n                <span className=\"text-xs font-medium text-foreground whitespace-nowrap\">\r\n                  {bar.label}\r\n                </span>\r\n              </div>\r\n              <div className=\"text-sm font-bold text-primary tabular-nums text-center\">\r\n                {bar.value}\r\n              </div>\r\n            </motion.div>\r\n          );\r\n        })()}\r\n      </AnimatePresence>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport const BarChart = memo(BarChartComponent);\r\nexport type { ChartDataItem, BarChartProps };\r\nexport { DEFAULT_COLORS, formatValue };\r\n"
      }
    ],
    "meta": {
      "importName": "BarChart",
      "exportName": "BarChart",
      "displayName": "Bar Chart"
    }
  },
  "line-chart": {
    "name": "line-chart",
    "type": "chart",
    "category": "charts",
    "subcategory": "basic",
    "description": "A sophisticated line chart component with triangular markers, textured area fills, multiple series support, gap handling, curve interpolation, and advanced animations",
    "dependencies": [
      "framer-motion"
    ],
    "devDependencies": [],
    "registryDependencies": [],
    "peerDependencies": [
      "react",
      "react-dom"
    ],
    "files": [
      {
        "name": "line-chart/index.tsx",
        "content": "\"use client\";\r\n\r\nimport * as React from \"react\";\r\nimport { memo, useMemo, useState, useRef, useCallback } from \"react\";\r\nimport { useIsomorphicLayoutEffect } from \"../../../../lib/hooks\";\r\nimport { motion, AnimatePresence, useReducedMotion } from \"framer-motion\";\r\nimport { cn } from \"../../../../lib/utils\";\r\n\r\n// Types\r\ntype ChartDataItem = Record<string, unknown>;\r\n\r\ninterface LineChartProps<T extends ChartDataItem> {\r\n  readonly data: readonly T[];\r\n  readonly x: keyof T;\r\n  readonly y: keyof T | readonly (keyof T)[];\r\n  readonly colors?: readonly string[];\r\n  readonly className?: string;\r\n  readonly height?: number;\r\n  readonly loading?: boolean;\r\n  readonly error?: string | null;\r\n  readonly animation?: boolean;\r\n  readonly strokeWidth?: number;\r\n  readonly curve?: 'linear' | 'monotone' | 'natural' | 'step';\r\n  readonly showDots?: boolean;\r\n  readonly showArea?: boolean;\r\n  readonly showGrid?: boolean;\r\n  readonly gridStyle?: 'solid' | 'dashed' | 'dotted';\r\n  readonly showLegend?: boolean;\r\n  readonly connectNulls?: boolean;\r\n  readonly onPointClick?: (data: T, index: number, series?: string) => void;\r\n}\r\n\r\n// Constants\r\nconst DEFAULT_COLORS = [\r\n  '#3b82f6', '#10b981', '#f59e0b', '#ef4444', '#8b5cf6', '#06b6d4',\r\n] as const;\r\n\r\nconst DEFAULT_HEIGHT = 300;\r\nconst MARGIN = { top: 20, right: 20, bottom: 40, left: 50 };\r\nconst ANIMATION_EASING = [0.4, 0, 0.2, 1] as const;\r\nconst HOVER_DURATION = 0.2;\r\nconst LEGEND_HEIGHT = 40;\r\n\r\n// Utilities\r\nfunction formatValue(value: unknown): string {\r\n  if (typeof value === 'number') {\r\n    if (Math.abs(value) >= 1000000) {\r\n      return `${(value / 1000000).toFixed(1)}M`;\r\n    } else if (Math.abs(value) >= 1000) {\r\n      return `${(value / 1000).toFixed(1)}K`;\r\n    }\r\n    return value.toLocaleString();\r\n  }\r\n  return String(value);\r\n}\r\n\r\nfunction getNumericValue(data: ChartDataItem, key: keyof ChartDataItem): number | null {\r\n  const value = data[key];\r\n  if (typeof value === 'number' && isFinite(value)) return value;\r\n  if (typeof value === 'string') {\r\n    const parsed = parseFloat(value.replace(/[,$%\\s]/g, ''));\r\n    if (isFinite(parsed)) return parsed;\r\n    if (process.env.NODE_ENV === 'development') {\r\n      console.warn(`[LineChart] Could not parse value \"${value}\" for key \"${String(key)}\". Treating as null.`);\r\n    }\r\n  }\r\n  if (process.env.NODE_ENV === 'development' && value !== null && value !== undefined) {\r\n    console.warn(`[LineChart] Unexpected value type for key \"${String(key)}\": ${typeof value}. Treating as null.`);\r\n  }\r\n  return null;\r\n}\r\n\r\nfunction calculateNiceTicks(min: number, max: number, count = 5): number[] {\r\n  if (min === max) return [min];\r\n  const range = max - min;\r\n  const roughStep = range / (count - 1);\r\n  const magnitude = Math.pow(10, Math.floor(Math.log10(roughStep)));\r\n  const normalizedStep = roughStep / magnitude;\r\n  let niceStep: number;\r\n  if (normalizedStep <= 1) niceStep = magnitude;\r\n  else if (normalizedStep <= 2) niceStep = 2 * magnitude;\r\n  else if (normalizedStep <= 5) niceStep = 5 * magnitude;\r\n  else niceStep = 10 * magnitude;\r\n  const niceMin = Math.floor(min / niceStep) * niceStep;\r\n  const niceMax = Math.ceil(max / niceStep) * niceStep;\r\n  const ticks: number[] = [];\r\n  for (let tick = niceMin; tick <= niceMax; tick += niceStep) {\r\n    ticks.push(tick);\r\n  }\r\n  return ticks;\r\n}\r\n\r\nfunction getGridDasharray(gridStyle: 'solid' | 'dashed' | 'dotted'): string {\r\n  switch (gridStyle) {\r\n    case 'solid': return 'none';\r\n    case 'dotted': return '2 4';\r\n    case 'dashed':\r\n    default: return '4 4';\r\n  }\r\n}\r\n\r\nfunction useContainerDimensions() {\r\n  const ref = useRef<HTMLDivElement>(null);\r\n  const [width, setWidth] = useState(0);\r\n\r\n  useIsomorphicLayoutEffect(() => {\r\n    const element = ref.current;\r\n    if (!element) return;\r\n\r\n    const updateWidth = () => {\r\n      setWidth(element.getBoundingClientRect().width);\r\n    };\r\n\r\n    updateWidth();\r\n    const resizeObserver = new ResizeObserver(updateWidth);\r\n    resizeObserver.observe(element);\r\n\r\n    return () => resizeObserver.disconnect();\r\n  }, []);\r\n\r\n  return [ref, width] as const;\r\n}\r\n\r\n// Path generation utilities\r\ntype PathPoint = { x: number; y: number; hasValue: boolean };\r\n\r\nfunction generatePath(points: PathPoint[], curve: 'linear' | 'monotone' | 'natural' | 'step', connectNulls = true): string {\r\n  if (!points.length) return '';\r\n\r\n  const validPoints = connectNulls ? points : points.filter(p => p?.hasValue);\r\n  if (!validPoints.length) return '';\r\n\r\n  if (curve === 'linear' || curve === 'step' || curve === 'natural' || validPoints.length < 2) {\r\n    return validPoints.reduce((path, point, i) =>\r\n      path + (i === 0 ? `M ${point.x} ${point.y}` : ` L ${point.x} ${point.y}`), '');\r\n  }\r\n\r\n  // Monotone curve\r\n  const firstPoint = validPoints[0];\r\n  if (!firstPoint) return '';\r\n\r\n  let path = `M ${firstPoint.x} ${firstPoint.y}`;\r\n\r\n  for (let i = 1; i < validPoints.length; i++) {\r\n    const prev = validPoints[i - 1];\r\n    const curr = validPoints[i];\r\n    const next = validPoints[i + 1];\r\n\r\n    if (!prev || !curr) continue;\r\n\r\n    const dx = curr.x - prev.x;\r\n    let cp1y = prev.y, cp2y = curr.y;\r\n\r\n    if (next && dx !== 0) {\r\n      const slope1 = (curr.y - prev.y) / dx;\r\n      const slope2 = (next.y - curr.y) / (next.x - curr.x);\r\n      const avgSlope = (slope1 + slope2) / 2;\r\n\r\n      cp1y = prev.y + dx * 0.3 * avgSlope;\r\n      cp2y = curr.y - dx * 0.3 * avgSlope;\r\n    }\r\n\r\n    path += ` C ${prev.x + dx * 0.3} ${cp1y}, ${curr.x - dx * 0.3} ${cp2y}, ${curr.x} ${curr.y}`;\r\n  }\r\n\r\n  return path;\r\n}\r\n\r\n// State components\r\nconst states = {\r\n  Loading: ({ height = DEFAULT_HEIGHT }: { height?: number }) => (\r\n    <div className=\"relative w-full flex items-center justify-center\" style={{ height }}>\r\n      <div className=\"w-full max-w-full p-6\">\r\n        <div className=\"animate-pulse bg-muted rounded h-4 w-32 mb-4\" />\r\n        <div className=\"relative border-l border-b border-muted/30\"\r\n             style={{ height: height - 100, margin: `0 ${MARGIN.right}px ${MARGIN.bottom}px ${MARGIN.left}px` }}>\r\n          <svg width=\"100%\" height=\"100%\" className=\"absolute inset-0\">\r\n            <defs>\r\n              <linearGradient id=\"loadingGradient\" x1=\"0%\" y1=\"0%\" x2=\"100%\" y2=\"0%\">\r\n                <stop offset=\"0%\" stopColor=\"transparent\" />\r\n                <stop offset=\"50%\" stopColor=\"currentColor\" stopOpacity={0.1} />\r\n                <stop offset=\"100%\" stopColor=\"transparent\" />\r\n              </linearGradient>\r\n            </defs>\r\n            {[0, 1, 2].map((i) => (\r\n              <motion.path\r\n                key={i}\r\n                d={`M 0 ${60 + i * 30} Q 100 ${40 + i * 30} 200 ${60 + i * 30} T 400 ${60 + i * 30}`}\r\n                stroke=\"url(#loadingGradient)\"\r\n                strokeWidth=\"2\"\r\n                fill=\"none\"\r\n                initial={{ pathLength: 0 }}\r\n                animate={{ pathLength: 1 }}\r\n                transition={{ duration: 2, repeat: Infinity, ease: \"easeInOut\", delay: i * 0.2 }}\r\n              />\r\n            ))}\r\n          </svg>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  ),\r\n\r\n  Error: ({ error }: { error: string }) => (\r\n    <div className=\"flex items-center justify-center h-64\">\r\n      <div className=\"text-center space-y-2\">\r\n        <div className=\"text-destructive font-medium\">Chart Error</div>\r\n        <div className=\"text-sm text-muted-foreground\">{error}</div>\r\n      </div>\r\n    </div>\r\n  ),\r\n\r\n  Empty: () => (\r\n    <div className=\"flex items-center justify-center h-64\">\r\n      <div className=\"text-center space-y-2\">\r\n        <div className=\"text-muted-foreground\">No Data</div>\r\n        <div className=\"text-sm text-muted-foreground\">There&apos;s no data to display</div>\r\n      </div>\r\n    </div>\r\n  ),\r\n};\r\n\r\n// Main Component\r\nfunction LineChartComponent<T extends ChartDataItem>({\r\n  data,\r\n  x,\r\n  y,\r\n  colors = DEFAULT_COLORS,\r\n  className,\r\n  height = DEFAULT_HEIGHT,\r\n  loading = false,\r\n  error = null,\r\n  animation = true,\r\n  strokeWidth = 2,\r\n  curve = 'monotone',\r\n  showDots = true,\r\n  showArea = false,\r\n  showGrid = false,\r\n  gridStyle = 'dashed',\r\n  showLegend = false,\r\n  connectNulls = true,\r\n  onPointClick,\r\n}: LineChartProps<T>) {\r\n  const [containerRef, containerWidth] = useContainerDimensions();\r\n  const [hoveredIndex, setHoveredIndex] = useState<number | null>(null);\r\n\r\n  const reduceMotion = useReducedMotion();\r\n  const shouldAnimate = animation && !reduceMotion;\r\n\r\n  const hasLegend = showLegend && Array.isArray(y) && y.length > 1;\r\n  const svgHeight = hasLegend ? height - LEGEND_HEIGHT : height;\r\n  const chartWidth = Math.max(0, containerWidth - MARGIN.left - MARGIN.right);\r\n  const chartHeight = svgHeight - MARGIN.top - MARGIN.bottom;\r\n\r\n  // Dev warning for large datasets\r\n  if (process.env.NODE_ENV === 'development' && data.length > 200) {\r\n    console.warn(\r\n      `[LineChart] ${data.length} data points detected. Consider downsampling for better performance.`\r\n    );\r\n  }\r\n\r\n  // Compute global domain across all series for shared Y-axis\r\n  const globalDomain = useMemo(() => {\r\n    if (!data.length) return { min: 0, max: 0 };\r\n\r\n    const yKeys = Array.isArray(y) ? y : [y];\r\n    let allMin = Infinity;\r\n    let allMax = -Infinity;\r\n\r\n    for (const yKey of yKeys) {\r\n      for (const item of data) {\r\n        const val = getNumericValue(item, yKey as string);\r\n        if (val !== null) {\r\n          if (val < allMin) allMin = val;\r\n          if (val > allMax) allMax = val;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (!isFinite(allMin) || !isFinite(allMax)) return { min: 0, max: 0 };\r\n    return { min: allMin, max: allMax };\r\n  }, [data, y]);\r\n\r\n  const yTicks = useMemo(() => {\r\n    if (globalDomain.min === globalDomain.max) return globalDomain.min === 0 ? [] : [globalDomain.min];\r\n    return calculateNiceTicks(globalDomain.min, globalDomain.max, 5);\r\n  }, [globalDomain]);\r\n\r\n  const gridDasharray = useMemo(() => getGridDasharray(gridStyle), [gridStyle]);\r\n\r\n  // Effective Y domain from nice ticks for consistent grid alignment\r\n  const effectiveDomain = useMemo(() => {\r\n    if (!yTicks.length) return globalDomain;\r\n    return { min: Math.min(...yTicks), max: Math.max(...yTicks) };\r\n  }, [yTicks, globalDomain]);\r\n\r\n  const processedSeries = useMemo(() => {\r\n    if (!data.length || chartWidth <= 0 || chartHeight <= 0) return [];\r\n\r\n    const yKeys = Array.isArray(y) ? y : [y];\r\n    const { min: scaleMin, max: scaleMax } = effectiveDomain;\r\n    const range = scaleMax - scaleMin || 1;\r\n\r\n    return yKeys.map((yKey, seriesIndex) => {\r\n      const seriesData = data.map((item, index) => {\r\n        const yVal = getNumericValue(item, yKey as string);\r\n        return {\r\n          data: item,\r\n          index,\r\n          xValue: item[x],\r\n          yValue: yVal,\r\n          hasValue: yVal !== null,\r\n          x: data.length > 1 ? (index / (data.length - 1)) * chartWidth : chartWidth / 2,\r\n          label: String(item[x]),\r\n          value: yVal !== null ? formatValue(yVal) : 'N/A',\r\n        };\r\n      });\r\n\r\n      const validValues = seriesData.filter(item => item.hasValue).map(item => item.yValue!);\r\n      if (!validValues.length) return null;\r\n\r\n      const seriesColor = colors[seriesIndex % colors.length] || DEFAULT_COLORS[0];\r\n\r\n      // Calculate y positions using shared domain\r\n      const points = seriesData.map(item => ({\r\n        ...item,\r\n        y: item.hasValue\r\n          ? chartHeight - ((item.yValue! - scaleMin) / range) * chartHeight\r\n          : chartHeight,\r\n        color: seriesColor,\r\n      }));\r\n\r\n      const linePath = generatePath(points, curve, connectNulls);\r\n      const areaPath = showArea && linePath\r\n        ? `${linePath} L ${chartWidth} ${chartHeight} L 0 ${chartHeight} Z`\r\n        : '';\r\n\r\n      return {\r\n        key: String(yKey),\r\n        points,\r\n        linePath,\r\n        areaPath,\r\n        color: seriesColor,\r\n        minValue: Math.min(...validValues),\r\n        maxValue: Math.max(...validValues),\r\n      };\r\n    }).filter((series): series is NonNullable<typeof series> => series !== null);\r\n  }, [data, x, y, colors, chartWidth, chartHeight, curve, connectNulls, showArea, effectiveDomain]);\r\n\r\n  // Event handlers with useCallback\r\n  const handlePointMouseEnter = useCallback((index: number) => {\r\n    setHoveredIndex(index);\r\n  }, []);\r\n\r\n  const handlePointMouseLeave = useCallback(() => {\r\n    setHoveredIndex(null);\r\n  }, []);\r\n\r\n  const handlePointClick = useCallback((pointData: T, index: number, series?: string) => {\r\n    onPointClick?.(pointData, index, series);\r\n  }, [onPointClick]);\r\n\r\n  const handleKeyDown = useCallback((e: React.KeyboardEvent, pointData: T, index: number, series?: string) => {\r\n    if (e.key === 'Enter' || e.key === ' ') {\r\n      e.preventDefault();\r\n      onPointClick?.(pointData, index, series);\r\n    }\r\n  }, [onPointClick]);\r\n\r\n  if (loading) return <states.Loading height={height} />;\r\n  if (error) return <states.Error error={error} />;\r\n  if (!data.length) return <states.Empty />;\r\n\r\n  if (!containerWidth) {\r\n    return (\r\n      <div ref={containerRef} className={cn('relative w-full', className)} style={{ height }}>\r\n        <div className=\"flex items-center justify-center h-full text-sm text-muted-foreground\">\r\n          Loading...\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  const { min: scaleMin, max: scaleMax } = effectiveDomain;\r\n  const scaleRange = scaleMax - scaleMin || 1;\r\n\r\n  return (\r\n    <div\r\n      ref={containerRef}\r\n      className={cn('relative w-full', className)}\r\n      style={{ height }}\r\n    >\r\n      <svg\r\n        width=\"100%\"\r\n        height={svgHeight}\r\n        className=\"overflow-visible\"\r\n        role=\"img\"\r\n        aria-label={`Line chart with ${processedSeries.length} series and ${data.length} data points`}\r\n      >\r\n        <defs>\r\n          {processedSeries.map((series, index) => (\r\n            <g key={`series-defs-${index}`}>\r\n              <linearGradient\r\n                id={`area-gradient-${index}`}\r\n                x1=\"0%\" y1=\"0%\" x2=\"0%\" y2=\"100%\"\r\n              >\r\n                <stop offset=\"0%\" stopColor={series.color} stopOpacity={0.2} />\r\n                <stop offset=\"100%\" stopColor={series.color} stopOpacity={0.05} />\r\n              </linearGradient>\r\n              <pattern\r\n                id={`dot-pattern-${index}`}\r\n                patternUnits=\"userSpaceOnUse\"\r\n                width=\"8\" height=\"8\"\r\n              >\r\n                <rect width=\"8\" height=\"8\" fill={`url(#area-gradient-${index})`} />\r\n                <circle cx=\"4\" cy=\"4\" r=\"0.6\" fill={series.color} fillOpacity=\"0.25\" />\r\n              </pattern>\r\n            </g>\r\n          ))}\r\n        </defs>\r\n\r\n        <g transform={`translate(${MARGIN.left}, ${MARGIN.top})`}>\r\n          {/* Grid lines */}\r\n          {showGrid && yTicks.map((tick, i) => {\r\n            const tickY = chartHeight - ((tick - scaleMin) / scaleRange) * chartHeight;\r\n            return (\r\n              <line\r\n                key={`grid-h-${i}`}\r\n                x1={0} y1={tickY} x2={chartWidth} y2={tickY}\r\n                stroke=\"currentColor\" opacity={0.1}\r\n                strokeDasharray={gridDasharray}\r\n              />\r\n            );\r\n          })}\r\n\r\n          {/* Axes */}\r\n          <line\r\n            x1={0} y1={0} x2={0} y2={chartHeight}\r\n            stroke=\"currentColor\" opacity={0.3} strokeWidth={1.5}\r\n          />\r\n          <line\r\n            x1={0} y1={chartHeight} x2={chartWidth} y2={chartHeight}\r\n            stroke=\"currentColor\" opacity={0.3} strokeWidth={1.5}\r\n          />\r\n\r\n          {/* Y-axis ticks and labels */}\r\n          {yTicks.map((tick, i) => {\r\n            const tickY = chartHeight - ((tick - scaleMin) / scaleRange) * chartHeight;\r\n            return (\r\n              <g key={`y-tick-${i}`}>\r\n                <line x1={-4} y1={tickY} x2={0} y2={tickY} stroke=\"currentColor\" opacity={0.3} />\r\n                <text\r\n                  x={-8} y={tickY}\r\n                  textAnchor=\"end\" dominantBaseline=\"middle\"\r\n                  fontSize={11} className=\"fill-muted-foreground\"\r\n                >\r\n                  {formatValue(tick)}\r\n                </text>\r\n              </g>\r\n            );\r\n          })}\r\n\r\n          {/* Hover line */}\r\n          {hoveredIndex !== null && data.length > 1 && (\r\n            <line\r\n              x1={(hoveredIndex / (data.length - 1)) * chartWidth}\r\n              y1={0}\r\n              x2={(hoveredIndex / (data.length - 1)) * chartWidth}\r\n              y2={chartHeight}\r\n              stroke=\"currentColor\"\r\n              opacity={0.3}\r\n              strokeWidth={1}\r\n              strokeDasharray=\"4 4\"\r\n            />\r\n          )}\r\n\r\n          {/* Areas and Lines */}\r\n          {processedSeries.map((series, seriesIndex) => {\r\n            const isSeriesHovered = hoveredIndex !== null && series.points[hoveredIndex]?.hasValue;\r\n\r\n            return (\r\n              <g key={`series-${seriesIndex}`}>\r\n                {showArea && (\r\n                  <motion.path\r\n                    d={series.areaPath}\r\n                    fill={`url(#dot-pattern-${seriesIndex})`}\r\n                    {...(shouldAnimate && {\r\n                      initial: { opacity: 0, scaleY: 0 },\r\n                      animate: { opacity: 1, scaleY: 1 },\r\n                      transition: {\r\n                        duration: 0.8,\r\n                        delay: seriesIndex * 0.15,\r\n                        ease: ANIMATION_EASING,\r\n                      }\r\n                    })}\r\n                    style={{ transformOrigin: 'bottom' }}\r\n                  />\r\n                )}\r\n                <motion.path\r\n                  d={series.linePath}\r\n                  stroke={series.color}\r\n                  strokeWidth={strokeWidth}\r\n                  fill=\"none\"\r\n                  strokeLinecap=\"round\"\r\n                  strokeLinejoin=\"round\"\r\n                  className=\"pointer-events-none\"\r\n                  style={{\r\n                    filter: isSeriesHovered && !reduceMotion ? `drop-shadow(0 0 8px ${series.color})` : 'none',\r\n                    transition: reduceMotion ? 'none' : `filter ${HOVER_DURATION}s ease-out`,\r\n                  }}\r\n                  {...(shouldAnimate && {\r\n                    initial: { pathLength: 0 },\r\n                    animate: { pathLength: 1 },\r\n                    transition: {\r\n                      duration: 1.2,\r\n                      delay: seriesIndex * 0.1,\r\n                      ease: ANIMATION_EASING,\r\n                    }\r\n                  })}\r\n                />\r\n              </g>\r\n            );\r\n          })}\r\n\r\n          {/* Invisible hit areas for line hover */}\r\n          {data.map((_, index) => {\r\n            const xPos = data.length > 1 ? (index / (data.length - 1)) * chartWidth : chartWidth / 2;\r\n            const sliceWidth = data.length > 1 ? chartWidth / (data.length - 1) : chartWidth;\r\n            return (\r\n              <rect\r\n                key={`hit-${index}`}\r\n                x={xPos - sliceWidth / 2}\r\n                y={0}\r\n                width={sliceWidth}\r\n                height={chartHeight}\r\n                fill=\"transparent\"\r\n                className=\"cursor-pointer touch-manipulation\"\r\n                onMouseEnter={() => handlePointMouseEnter(index)}\r\n                onMouseLeave={handlePointMouseLeave}\r\n                onClick={() => {\r\n                  const firstSeries = processedSeries[0];\r\n                  if (!firstSeries) return;\r\n                  const point = firstSeries.points[index];\r\n                  if (point?.hasValue) handlePointClick(point.data, index, firstSeries.key);\r\n                }}\r\n              />\r\n            );\r\n          })}\r\n\r\n          {/* Triangle Dots */}\r\n          {showDots && processedSeries.flatMap((series, seriesIndex) =>\r\n            series.points\r\n              .filter((point) => point.hasValue)\r\n              .map((point) => {\r\n                const isHovered = hoveredIndex === point.index;\r\n                const size = isHovered ? 10 : 7;\r\n                const trianglePath = `M ${point.x} ${point.y - size} L ${point.x - size * 0.866} ${point.y + size * 0.5} L ${point.x + size * 0.866} ${point.y + size * 0.5} Z`;\r\n\r\n                return (\r\n                  <motion.path\r\n                    key={`triangle-${seriesIndex}-${point.index}`}\r\n                    d={trianglePath}\r\n                    fill={series.color}\r\n                    stroke=\"hsl(var(--background))\"\r\n                    strokeWidth={2}\r\n                    className=\"cursor-pointer touch-manipulation focus:outline-none focus-visible:ring-2 focus-visible:ring-ring\"\r\n                    tabIndex={0}\r\n                    role=\"graphics-symbol\"\r\n                    aria-label={`${series.key}: ${point.label}, ${point.value}`}\r\n                    onMouseEnter={() => handlePointMouseEnter(point.index)}\r\n                    onMouseLeave={handlePointMouseLeave}\r\n                    onFocus={() => handlePointMouseEnter(point.index)}\r\n                    onBlur={handlePointMouseLeave}\r\n                    onClick={() => handlePointClick(point.data, point.index, series.key)}\r\n                    onKeyDown={(e) => handleKeyDown(e, point.data, point.index, series.key)}\r\n                    style={{\r\n                      filter: isHovered && !reduceMotion ? `drop-shadow(0 0 6px ${series.color})` : 'none',\r\n                      transition: reduceMotion ? 'none' : `filter ${HOVER_DURATION}s ease-out`,\r\n                    }}\r\n                    {...(shouldAnimate && {\r\n                      initial: { scale: 0, rotate: -180 },\r\n                      animate: { scale: 1, rotate: 0 },\r\n                      whileHover: { scale: 1.3, rotate: 360 },\r\n                      transition: {\r\n                        duration: 0.4,\r\n                        delay: seriesIndex * 0.1 + point.index * 0.02,\r\n                        ease: ANIMATION_EASING,\r\n                      }\r\n                    })}\r\n                  />\r\n                );\r\n              })\r\n          )}\r\n\r\n          {/* X-axis labels with tick marks */}\r\n          {data.map((item, index) => {\r\n            const xPos = data.length > 1 ? (index / (data.length - 1)) * chartWidth : chartWidth / 2;\r\n            return (\r\n              <g key={`x-label-${index}`}>\r\n                <line\r\n                  x1={xPos} y1={chartHeight}\r\n                  x2={xPos} y2={chartHeight + 4}\r\n                  stroke=\"currentColor\" opacity={0.3}\r\n                />\r\n                <text\r\n                  x={xPos}\r\n                  y={chartHeight + 16}\r\n                  textAnchor=\"middle\"\r\n                  fontSize={11}\r\n                  className=\"fill-muted-foreground\"\r\n                >\r\n                  {String(item[x])}\r\n                </text>\r\n              </g>\r\n            );\r\n          })}\r\n        </g>\r\n      </svg>\r\n\r\n      {/* Tooltip */}\r\n      <AnimatePresence>\r\n        {hoveredIndex !== null && hoveredIndex >= 0 && (() => {\r\n          const tooltipData = processedSeries\r\n            .map(series => ({\r\n              key: series.key,\r\n              color: series.color,\r\n              point: series.points[hoveredIndex]\r\n            }))\r\n            .filter(item => item.point?.hasValue);\r\n\r\n          if (!tooltipData.length) return null;\r\n\r\n          return (\r\n            <motion.div\r\n              key=\"line-tooltip\"\r\n              initial={{ opacity: 0, scale: 0.9 }}\r\n              animate={{ opacity: 1, scale: 1 }}\r\n              exit={{ opacity: 0, scale: 0.9 }}\r\n              transition={{ duration: 0.15, ease: 'easeOut' }}\r\n              className=\"absolute pointer-events-none z-50 bg-popover/98 backdrop-blur-md border border-border rounded-lg px-3 py-2.5 shadow-xl transform -translate-x-1/2\"\r\n              style={{\r\n                left: data.length > 1\r\n                  ? (hoveredIndex / (data.length - 1)) * chartWidth + MARGIN.left\r\n                  : chartWidth / 2 + MARGIN.left,\r\n                top: Math.max(10, MARGIN.top - 10),\r\n              }}\r\n            >\r\n              <div className=\"text-xs font-medium text-foreground mb-1.5 pb-1.5 border-b border-border/50 text-center whitespace-nowrap\">\r\n                {tooltipData[0]?.point?.label || ''}\r\n              </div>\r\n              {tooltipData.map(({ key, point, color }) => (\r\n                <div key={key} className=\"flex items-center justify-between gap-3 py-0.5\">\r\n                  <div className=\"flex items-center gap-1.5\">\r\n                    <div className=\"w-2 h-2 rounded-full\" style={{ backgroundColor: color }} />\r\n                    {processedSeries.length > 1 && (\r\n                      <span className=\"text-xs text-muted-foreground\">{key}</span>\r\n                    )}\r\n                  </div>\r\n                  <span className=\"text-xs font-bold text-foreground tabular-nums\">{point!.value}</span>\r\n                </div>\r\n              ))}\r\n            </motion.div>\r\n          );\r\n        })()}\r\n      </AnimatePresence>\r\n\r\n      {/* Legend */}\r\n      {hasLegend && processedSeries.length > 1 && (\r\n        <div className=\"flex flex-wrap gap-4 justify-center px-4\" style={{ height: LEGEND_HEIGHT }}>\r\n          {processedSeries.map((series) => (\r\n            <div key={series.key} className=\"flex items-center space-x-2\">\r\n              <div\r\n                className=\"w-3 h-3 rounded-full\"\r\n                style={{ backgroundColor: series.color }}\r\n              />\r\n              <span className=\"text-sm text-muted-foreground\">{series.key}</span>\r\n            </div>\r\n          ))}\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n}\r\n\r\nexport const LineChart = memo(LineChartComponent);\r\nexport type { ChartDataItem, LineChartProps };\r\nexport { DEFAULT_COLORS, formatValue };\r\n"
      }
    ],
    "meta": {
      "importName": "LineChart",
      "exportName": "LineChart",
      "displayName": "Line Chart"
    }
  },
  "scatter-plot": {
    "name": "scatter-plot",
    "type": "chart",
    "category": "charts",
    "subcategory": "basic",
    "description": "A versatile scatter plot and bubble chart component with multi-series support, trend lines, dynamic bubble sizing, responsive design, and smooth animations",
    "dependencies": [
      "framer-motion"
    ],
    "devDependencies": [],
    "registryDependencies": [],
    "peerDependencies": [
      "react",
      "react-dom"
    ],
    "files": [
      {
        "name": "scatter-plot/index.tsx",
        "content": "\"use client\";\r\n\r\nimport * as React from \"react\";\r\nimport { memo, useMemo, useState, useRef, useLayoutEffect, useCallback } from \"react\";\r\nimport { motion, AnimatePresence, useReducedMotion } from \"framer-motion\";\r\nimport { cn } from \"../../../../lib/utils\";\r\n\r\n// Internal modules\r\nimport type {\r\n  ChartDataItem,\r\n  ScatterPlotProps,\r\n  ProcessedPoint,\r\n  ProcessedSeries,\r\n  HoveredPoint,\r\n  TrendLine,\r\n} from \"./types\";\r\nimport {\r\n  scaleValue,\r\n  calculateNiceTicks,\r\n  getNumericValue,\r\n  formatValue,\r\n  getGridDasharray,\r\n} from \"./scales\";\r\nimport { calculateLinearRegression } from \"./regression\";\r\n\r\n// Re-export types for consumers\r\nexport type { ChartDataItem, ScatterPlotProps };\r\n\r\n// Constants\r\nconst DEFAULT_COLORS = [\r\n  '#3b82f6', '#10b981', '#f59e0b', '#ef4444', '#8b5cf6', '#06b6d4',\r\n] as const;\r\n\r\nconst DEFAULT_HEIGHT = 300;\r\nconst DEFAULT_POINT_SIZE = 6;\r\nconst DEFAULT_SIZE_RANGE = [4, 40] as const;\r\nconst MARGIN = { top: 20, right: 20, bottom: 40, left: 50 };\r\n\r\n// Custom hook for container dimensions\r\nfunction useContainerDimensions() {\r\n  const ref = useRef<HTMLDivElement>(null);\r\n  const [width, setWidth] = useState(0);\r\n\r\n  useLayoutEffect(() => {\r\n    const element = ref.current;\r\n    if (!element) return;\r\n\r\n    const updateWidth = () => {\r\n      setWidth(element.getBoundingClientRect().width);\r\n    };\r\n\r\n    updateWidth();\r\n    const resizeObserver = new ResizeObserver(updateWidth);\r\n    resizeObserver.observe(element);\r\n\r\n    return () => resizeObserver.disconnect();\r\n  }, []);\r\n\r\n  return [ref, width] as const;\r\n}\r\n\r\n// State components\r\nconst states = {\r\n  Loading: ({ height = DEFAULT_HEIGHT, shouldAnimate = true }: { height?: number; shouldAnimate?: boolean }) => (\r\n    <div className=\"relative w-full flex items-center justify-center\" style={{ height }}>\r\n      <div className=\"w-full max-w-full p-6\">\r\n        <div className=\"animate-pulse bg-muted rounded h-4 w-32 mb-4\" />\r\n        <div className=\"relative border-l border-b border-muted/30\"\r\n             style={{ height: height - 100, margin: '0 50px 40px 50px' }}>\r\n          <svg width=\"100%\" height=\"100%\" className=\"absolute inset-0\">\r\n            {Array.from({ length: 12 }).map((_, i) => (\r\n              shouldAnimate ? (\r\n                <motion.circle\r\n                  key={i}\r\n                  cx={`${15 + (i % 4) * 25}%`}\r\n                  cy={`${20 + Math.floor(i / 4) * 30}%`}\r\n                  r={6 + (i % 3) * 4}\r\n                  className=\"fill-muted\"\r\n                  initial={{ scale: 0, opacity: 0 }}\r\n                  animate={{ scale: 1, opacity: 0.5 }}\r\n                  transition={{\r\n                    duration: 0.5,\r\n                    delay: i * 0.08,\r\n                    repeat: Infinity,\r\n                    repeatType: \"reverse\",\r\n                    repeatDelay: 1\r\n                  }}\r\n                />\r\n              ) : (\r\n                <circle\r\n                  key={i}\r\n                  cx={`${15 + (i % 4) * 25}%`}\r\n                  cy={`${20 + Math.floor(i / 4) * 30}%`}\r\n                  r={6 + (i % 3) * 4}\r\n                  className=\"fill-muted opacity-50\"\r\n                />\r\n              )\r\n            ))}\r\n          </svg>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  ),\r\n\r\n  Error: ({ error }: { error: string }) => (\r\n    <div className=\"flex items-center justify-center h-64\">\r\n      <div className=\"text-center space-y-2\">\r\n        <div className=\"text-destructive font-medium\">Chart Error</div>\r\n        <div className=\"text-sm text-muted-foreground\">{error}</div>\r\n      </div>\r\n    </div>\r\n  ),\r\n\r\n  Empty: () => (\r\n    <div className=\"flex items-center justify-center h-64\">\r\n      <div className=\"text-center space-y-2\">\r\n        <div className=\"text-muted-foreground\">No Data</div>\r\n        <div className=\"text-sm text-muted-foreground\">There&apos;s no data to display</div>\r\n      </div>\r\n    </div>\r\n  ),\r\n};\r\n\r\n// Main Component\r\nfunction ScatterPlotComponent<T extends ChartDataItem>({\r\n  data,\r\n  x,\r\n  y,\r\n  colors = DEFAULT_COLORS,\r\n  className,\r\n  height = DEFAULT_HEIGHT,\r\n  loading = false,\r\n  error = null,\r\n  animation = true,\r\n  series,\r\n  size,\r\n  sizeRange = DEFAULT_SIZE_RANGE,\r\n  showTrendLine = false,\r\n  trendLineColor,\r\n  showLegend = false,\r\n  showGrid = false,\r\n  gridStyle = 'dashed',\r\n  xDomain,\r\n  yDomain,\r\n  onPointClick,\r\n}: ScatterPlotProps<T>) {\r\n  const [containerRef, containerWidth] = useContainerDimensions();\r\n  const [hoveredPoint, setHoveredPoint] = useState<HoveredPoint | null>(null);\r\n\r\n  // Respect user's motion preferences (WCAG)\r\n  const reduceMotion = useReducedMotion();\r\n  const shouldAnimate = animation && !reduceMotion;\r\n\r\n  const chartWidth = Math.max(0, containerWidth - MARGIN.left - MARGIN.right);\r\n  const chartHeight = height - MARGIN.top - MARGIN.bottom;\r\n\r\n  // Memoized: Extract raw points from data\r\n  const rawPoints = useMemo(() => {\r\n    if (!data.length) return [];\r\n\r\n    return data.map((item, index) => {\r\n      const xVal = getNumericValue(item, x as string);\r\n      const yVal = getNumericValue(item, y as string);\r\n      const sizeVal = typeof size === 'number'\r\n        ? size\r\n        : size\r\n          ? getNumericValue(item, size as string) ?? DEFAULT_POINT_SIZE\r\n          : DEFAULT_POINT_SIZE;\r\n      const seriesKey = series ? String(item[series]) : 'default';\r\n\r\n      return {\r\n        data: item,\r\n        index,\r\n        xValue: xVal,\r\n        yValue: yVal,\r\n        sizeValue: sizeVal,\r\n        seriesKey,\r\n        label: series ? String(item[series]) : `Point ${index + 1}`,\r\n      };\r\n    }).filter(p => p.xValue !== null && p.yValue !== null) as Array<{\r\n      data: T;\r\n      index: number;\r\n      xValue: number;\r\n      yValue: number;\r\n      sizeValue: number;\r\n      seriesKey: string;\r\n      label: string;\r\n    }>;\r\n  }, [data, x, y, series, size]);\r\n\r\n  // Memoized: Calculate domains from raw points\r\n  const domains = useMemo(() => {\r\n    if (!rawPoints.length) {\r\n      return {\r\n        xMin: 0, xMax: 1,\r\n        yMin: 0, yMax: 1,\r\n        sizeMin: DEFAULT_POINT_SIZE,\r\n        sizeMax: DEFAULT_POINT_SIZE,\r\n        effectiveXDomain: [0, 1] as readonly [number, number],\r\n        effectiveYDomain: [0, 1] as readonly [number, number],\r\n      };\r\n    }\r\n\r\n    const xValues = rawPoints.map(p => p.xValue);\r\n    const yValues = rawPoints.map(p => p.yValue);\r\n    const sizeValues = rawPoints.map(p => p.sizeValue);\r\n\r\n    const xMin = Math.min(...xValues);\r\n    const xMax = Math.max(...xValues);\r\n    const yMin = Math.min(...yValues);\r\n    const yMax = Math.max(...yValues);\r\n    const sizeMin = Math.min(...sizeValues);\r\n    const sizeMax = Math.max(...sizeValues);\r\n\r\n    // Add 5% padding to domains\r\n    const xPadding = (xMax - xMin) * 0.05 || 1;\r\n    const yPadding = (yMax - yMin) * 0.05 || 1;\r\n\r\n    const effectiveXDomain: readonly [number, number] = xDomain ?? [xMin - xPadding, xMax + xPadding];\r\n    const effectiveYDomain: readonly [number, number] = yDomain ?? [yMin - yPadding, yMax + yPadding];\r\n\r\n    return {\r\n      xMin, xMax, yMin, yMax, sizeMin, sizeMax,\r\n      effectiveXDomain,\r\n      effectiveYDomain,\r\n    };\r\n  }, [rawPoints, xDomain, yDomain]);\r\n\r\n  // Memoized: Calculate axis ticks\r\n  const { xTicks, yTicks } = useMemo(() => ({\r\n    xTicks: calculateNiceTicks(domains.effectiveXDomain[0], domains.effectiveXDomain[1], 6),\r\n    yTicks: calculateNiceTicks(domains.effectiveYDomain[0], domains.effectiveYDomain[1], 5),\r\n  }), [domains.effectiveXDomain, domains.effectiveYDomain]);\r\n\r\n  // Memoized: Process series with screen coordinates\r\n  const processedSeries = useMemo(() => {\r\n    if (!rawPoints.length || chartWidth <= 0 || chartHeight <= 0) {\r\n      return [] as ProcessedSeries<T>[];\r\n    }\r\n\r\n    const { effectiveXDomain, effectiveYDomain, sizeMin, sizeMax } = domains;\r\n\r\n    // Group by series\r\n    const seriesGroups = new Map<string, typeof rawPoints>();\r\n    rawPoints.forEach(point => {\r\n      const existing = seriesGroups.get(point.seriesKey) || [];\r\n      existing.push(point);\r\n      seriesGroups.set(point.seriesKey, existing);\r\n    });\r\n\r\n    // Process each series\r\n    return Array.from(seriesGroups.entries()).map(\r\n      ([seriesKey, points], seriesIndex): ProcessedSeries<T> => {\r\n        const seriesColor = colors[seriesIndex % colors.length] || DEFAULT_COLORS[0];\r\n\r\n        const processedPoints: ProcessedPoint<T>[] = points.map(point => ({\r\n          ...point,\r\n          screenX: scaleValue(point.xValue, effectiveXDomain, [0, chartWidth]),\r\n          screenY: scaleValue(point.yValue, effectiveYDomain, [chartHeight, 0]),\r\n          radius: typeof size === 'number' || !size\r\n            ? (typeof size === 'number' ? size : DEFAULT_POINT_SIZE)\r\n            : scaleValue(point.sizeValue, [sizeMin, sizeMax], sizeRange),\r\n          color: seriesColor,\r\n          formattedX: formatValue(point.xValue),\r\n          formattedY: formatValue(point.yValue),\r\n          formattedSize: size && typeof size !== 'number' ? formatValue(point.sizeValue) : null,\r\n        }));\r\n\r\n        // Calculate trend line if enabled\r\n        let trendLine: TrendLine | null = null;\r\n        if (showTrendLine && processedPoints.length >= 2) {\r\n          const regression = calculateLinearRegression(\r\n            processedPoints.map(p => ({ x: p.xValue, y: p.yValue }))\r\n          );\r\n\r\n          // Calculate line endpoints within domain\r\n          const lineX1 = effectiveXDomain[0];\r\n          const lineX2 = effectiveXDomain[1];\r\n          const lineY1 = regression.slope * lineX1 + regression.intercept;\r\n          const lineY2 = regression.slope * lineX2 + regression.intercept;\r\n\r\n          trendLine = {\r\n            ...regression,\r\n            screenX1: scaleValue(lineX1, effectiveXDomain, [0, chartWidth]),\r\n            screenY1: scaleValue(lineY1, effectiveYDomain, [chartHeight, 0]),\r\n            screenX2: scaleValue(lineX2, effectiveXDomain, [0, chartWidth]),\r\n            screenY2: scaleValue(lineY2, effectiveYDomain, [chartHeight, 0]),\r\n          };\r\n        }\r\n\r\n        return {\r\n          key: seriesKey,\r\n          color: seriesColor,\r\n          points: processedPoints,\r\n          trendLine,\r\n        };\r\n      }\r\n    );\r\n  }, [rawPoints, domains, colors, chartWidth, chartHeight, size, sizeRange, showTrendLine]);\r\n\r\n  // Memoized callback: Get hovered point data for tooltip\r\n  const hoveredData = useMemo(() => {\r\n    if (!hoveredPoint) return null;\r\n    const seriesData = processedSeries.find(s => s.key === hoveredPoint.series);\r\n    if (!seriesData) return null;\r\n    const point = seriesData.points.find(p => p.index === hoveredPoint.index);\r\n    return point ? { point, seriesKey: seriesData.key, color: seriesData.color } : null;\r\n  }, [hoveredPoint, processedSeries]);\r\n\r\n  // Memoized: Grid dasharray\r\n  const gridDasharray = useMemo(() => getGridDasharray(gridStyle), [gridStyle]);\r\n\r\n  // Callbacks for event handlers\r\n  const handleMouseEnter = useCallback((index: number, seriesKey: string) => {\r\n    setHoveredPoint({ index, series: seriesKey });\r\n  }, []);\r\n\r\n  const handleMouseLeave = useCallback(() => {\r\n    setHoveredPoint(null);\r\n  }, []);\r\n\r\n  const handlePointClick = useCallback((point: ProcessedPoint<T>, seriesKey: string) => {\r\n    onPointClick?.(point.data, point.index, seriesKey);\r\n  }, [onPointClick]);\r\n\r\n  // Keyboard handler for point interaction (WCAG)\r\n  const handleKeyDown = useCallback((\r\n    e: React.KeyboardEvent,\r\n    point: ProcessedPoint<T>,\r\n    seriesKey: string\r\n  ) => {\r\n    if (e.key === 'Enter' || e.key === ' ') {\r\n      e.preventDefault();\r\n      onPointClick?.(point.data, point.index, seriesKey);\r\n    }\r\n  }, [onPointClick]);\r\n\r\n  // Early returns for different states\r\n  if (loading) return <states.Loading height={height} shouldAnimate={shouldAnimate} />;\r\n  if (error) return <states.Error error={error} />;\r\n  // If no data provided or no plottable points (non-numeric x/y), show empty state\r\n  // Note: Use rawPoints.length instead of processedSeries.length because processedSeries depends on containerWidth\r\n  if (!data.length || rawPoints.length === 0) return <states.Empty />;\r\n\r\n  if (!containerWidth) {\r\n    return (\r\n      <div ref={containerRef} className={cn('relative w-full', className)} style={{ height }}>\r\n        <div className=\"flex items-center justify-center h-full text-sm text-muted-foreground\">\r\n          Loading...\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  return (\r\n    <div\r\n      ref={containerRef}\r\n      className={cn('relative w-full', className)}\r\n      style={{ height }}\r\n    >\r\n      <svg width=\"100%\" height={height} className=\"overflow-visible\">\r\n        <g transform={`translate(${MARGIN.left}, ${MARGIN.top})`}>\r\n          {/* Grid lines */}\r\n          {showGrid && (\r\n            <>\r\n              {/* Horizontal grid lines */}\r\n              {yTicks.map((tick, i) => {\r\n                const tickY = scaleValue(tick, domains.effectiveYDomain, [chartHeight, 0]);\r\n                return (\r\n                  <line\r\n                    key={`grid-h-${i}`}\r\n                    x1={0}\r\n                    y1={tickY}\r\n                    x2={chartWidth}\r\n                    y2={tickY}\r\n                    stroke=\"currentColor\"\r\n                    opacity={0.1}\r\n                    strokeDasharray={gridDasharray}\r\n                  />\r\n                );\r\n              })}\r\n              {/* Vertical grid lines */}\r\n              {xTicks.map((tick, i) => {\r\n                const tickX = scaleValue(tick, domains.effectiveXDomain, [0, chartWidth]);\r\n                return (\r\n                  <line\r\n                    key={`grid-v-${i}`}\r\n                    x1={tickX}\r\n                    y1={0}\r\n                    x2={tickX}\r\n                    y2={chartHeight}\r\n                    stroke=\"currentColor\"\r\n                    opacity={0.1}\r\n                    strokeDasharray={gridDasharray}\r\n                  />\r\n                );\r\n              })}\r\n            </>\r\n          )}\r\n\r\n          {/* Y Axis */}\r\n          <line\r\n            x1={0}\r\n            y1={0}\r\n            x2={0}\r\n            y2={chartHeight}\r\n            stroke=\"currentColor\"\r\n            opacity={0.3}\r\n            strokeWidth={1.5}\r\n          />\r\n\r\n          {/* X Axis */}\r\n          <line\r\n            x1={0}\r\n            y1={chartHeight}\r\n            x2={chartWidth}\r\n            y2={chartHeight}\r\n            stroke=\"currentColor\"\r\n            opacity={0.3}\r\n            strokeWidth={1.5}\r\n          />\r\n\r\n          {/* Y Axis ticks and labels */}\r\n          {yTicks.map((tick, i) => {\r\n            const tickY = scaleValue(tick, domains.effectiveYDomain, [chartHeight, 0]);\r\n            return (\r\n              <g key={`y-tick-${i}`}>\r\n                <line\r\n                  x1={-4}\r\n                  y1={tickY}\r\n                  x2={0}\r\n                  y2={tickY}\r\n                  stroke=\"currentColor\"\r\n                  opacity={0.3}\r\n                />\r\n                <text\r\n                  x={-8}\r\n                  y={tickY}\r\n                  textAnchor=\"end\"\r\n                  dominantBaseline=\"middle\"\r\n                  fontSize={11}\r\n                  className=\"fill-muted-foreground\"\r\n                >\r\n                  {formatValue(tick)}\r\n                </text>\r\n              </g>\r\n            );\r\n          })}\r\n\r\n          {/* X Axis ticks and labels */}\r\n          {xTicks.map((tick, i) => {\r\n            const tickX = scaleValue(tick, domains.effectiveXDomain, [0, chartWidth]);\r\n            return (\r\n              <g key={`x-tick-${i}`}>\r\n                <line\r\n                  x1={tickX}\r\n                  y1={chartHeight}\r\n                  x2={tickX}\r\n                  y2={chartHeight + 4}\r\n                  stroke=\"currentColor\"\r\n                  opacity={0.3}\r\n                />\r\n                <text\r\n                  x={tickX}\r\n                  y={chartHeight + 16}\r\n                  textAnchor=\"middle\"\r\n                  fontSize={11}\r\n                  className=\"fill-muted-foreground\"\r\n                >\r\n                  {formatValue(tick)}\r\n                </text>\r\n              </g>\r\n            );\r\n          })}\r\n\r\n          {/* Trend lines */}\r\n          {showTrendLine && processedSeries.map((series, seriesIndex) => (\r\n            series.trendLine && (\r\n              <motion.line\r\n                key={`trend-${seriesIndex}`}\r\n                x1={series.trendLine.screenX1}\r\n                y1={series.trendLine.screenY1}\r\n                x2={series.trendLine.screenX2}\r\n                y2={series.trendLine.screenY2}\r\n                stroke={trendLineColor || series.color}\r\n                strokeWidth={2}\r\n                strokeDasharray=\"6 4\"\r\n                opacity={0.6}\r\n                {...(shouldAnimate && {\r\n                  initial: { pathLength: 0, opacity: 0 },\r\n                  animate: { pathLength: 1, opacity: 0.6 },\r\n                  transition: {\r\n                    duration: 0.8,\r\n                    delay: 0.5 + seriesIndex * 0.1,\r\n                    ease: [0.4, 0, 0.2, 1]\r\n                  }\r\n                })}\r\n              />\r\n            )\r\n          ))}\r\n\r\n          {/* Points */}\r\n          {processedSeries.flatMap((series, seriesIndex) =>\r\n            series.points.map((point, pointIndex) => {\r\n              const isHovered = hoveredPoint?.index === point.index && hoveredPoint?.series === series.key;\r\n              const ariaLabel = `${series.key !== 'default' ? `${series.key}: ` : ''}X ${point.formattedX}, Y ${point.formattedY}${point.formattedSize ? `, size ${point.formattedSize}` : ''}`;\r\n\r\n              return (\r\n                <motion.circle\r\n                  key={`point-${seriesIndex}-${pointIndex}`}\r\n                  cx={point.screenX}\r\n                  cy={point.screenY}\r\n                  r={isHovered ? point.radius * 1.2 : point.radius}\r\n                  fill={point.color}\r\n                  stroke=\"white\"\r\n                  strokeWidth={2}\r\n                  className=\"cursor-pointer focus:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2\"\r\n                  style={{ transformOrigin: `${point.screenX}px ${point.screenY}px` }}\r\n                  // Mouse interactions\r\n                  onMouseEnter={() => handleMouseEnter(point.index, series.key)}\r\n                  onMouseLeave={handleMouseLeave}\r\n                  onClick={() => handlePointClick(point, series.key)}\r\n                  // Keyboard accessibility (WCAG)\r\n                  tabIndex={0}\r\n                  role=\"button\"\r\n                  aria-label={ariaLabel}\r\n                  onFocus={() => handleMouseEnter(point.index, series.key)}\r\n                  onBlur={handleMouseLeave}\r\n                  onKeyDown={(e) => handleKeyDown(e, point, series.key)}\r\n                  {...(shouldAnimate && {\r\n                    initial: { scale: 0, opacity: 0 },\r\n                    animate: { scale: 1, opacity: 1 },\r\n                    transition: {\r\n                      duration: 0.4,\r\n                      delay: seriesIndex * 0.1 + pointIndex * 0.02,\r\n                      ease: [0.4, 0, 0.2, 1]\r\n                    }\r\n                  })}\r\n                />\r\n              );\r\n            })\r\n          )}\r\n        </g>\r\n      </svg>\r\n\r\n      {/* Tooltip with AnimatePresence for proper exit animations */}\r\n      <AnimatePresence>\r\n        {hoveredData && (\r\n          <motion.div\r\n            initial={{ opacity: 0, y: 5 }}\r\n            animate={{ opacity: 1, y: 0 }}\r\n            exit={{ opacity: 0, y: 5 }}\r\n            className=\"absolute pointer-events-none z-50 bg-background border rounded-lg px-3 py-2 shadow-xl transform -translate-x-1/2\"\r\n            style={{\r\n              left: hoveredData.point.screenX + MARGIN.left,\r\n              top: Math.max(10, hoveredData.point.screenY + MARGIN.top - 80),\r\n            }}\r\n          >\r\n            {processedSeries.length > 1 && (\r\n              <div className=\"flex items-center gap-2 mb-1\">\r\n                <div className=\"w-2 h-2 rounded-full\" style={{ backgroundColor: hoveredData.color }} />\r\n                <span className=\"text-xs font-medium\">{hoveredData.seriesKey}</span>\r\n              </div>\r\n            )}\r\n            <div className=\"text-xs text-muted-foreground\">\r\n              X: <span className=\"font-medium text-foreground\">{hoveredData.point.formattedX}</span>\r\n            </div>\r\n            <div className=\"text-xs text-muted-foreground\">\r\n              Y: <span className=\"font-medium text-foreground\">{hoveredData.point.formattedY}</span>\r\n            </div>\r\n            {hoveredData.point.formattedSize && (\r\n              <div className=\"text-xs text-muted-foreground\">\r\n                Size: <span className=\"font-medium text-foreground\">{hoveredData.point.formattedSize}</span>\r\n              </div>\r\n            )}\r\n          </motion.div>\r\n        )}\r\n      </AnimatePresence>\r\n\r\n      {/* Legend */}\r\n      {showLegend && processedSeries.length > 1 && (\r\n        <div className=\"flex flex-wrap gap-4 justify-center mt-2 px-4\">\r\n          {processedSeries.map((series) => (\r\n            <div key={series.key} className=\"flex items-center space-x-2\">\r\n              <div\r\n                className=\"w-3 h-3 rounded-full\"\r\n                style={{ backgroundColor: series.color }}\r\n              />\r\n              <span className=\"text-sm text-muted-foreground\">{series.key}</span>\r\n            </div>\r\n          ))}\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n}\r\n\r\nexport const ScatterPlot = memo(ScatterPlotComponent);\r\nexport { DEFAULT_COLORS, formatValue };\r\n"
      }
    ],
    "meta": {
      "importName": "ScatterPlot",
      "exportName": "ScatterPlot",
      "displayName": "Scatter Plot"
    }
  }
};
